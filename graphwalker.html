<?xml version="1.0" standalone="yes"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Graph walker game</title>
<meta content="">
<style>
body{background:lightgray; text-align:center;}
svg{width:500px; height:500px; border: 2px solid black; background:white;}
svg .p1{fill:red; stroke:red;}
svg .p2{fill:blue; stroke:blue;}
text {font-size:0.1; text-anchor:middle; stroke-width:0;}
.grid{stroke:gray; stroke-width:.003;}
.grid .used{stroke-width:.015;}
.grid .pruned{stroke-width:.015;stroke:lightgray;}

.current .wave{fill:transparent !important;}
.current {stroke:black; stroke-width:0;}

.points{fill:black; stroke:black !important;stroke-width:.005;}
.points .near{stroke-width:.01;}
.points .used{fill:gray;}
.points .pruned{fill:white;stroke:lightgray;}
.initial{stroke:black;}
.near:hover{cursor:pointer;}
</style>
<script>
// svg namespace
var SVG="http://www.w3.org/2000/svg";
var SCALE=1/8+1/32;
var DEFAULT_DOT_RADIUS=0.02;
var NEAR_DOT_RADIUS=0.03;
var NAME=["","Red","Blue"];

// Create and append a new element
// Don't use style in pars. Gives 'component not available' exception.
var add=function(nodetype,node,pars){
	var e=document.createElementNS(SVG,nodetype);
	for (p in pars) {
		e.setAttribute(p,pars[p]);
	}
	node.appendChild(e);
	return e;
}

var add_class=function(e,cls) {
	e.setAttribute("class",e.hasAttribute("class")?e.getAttribute("class")+' '+cls:cls);
}
var remove_class=function(e,cls) {
	if(!e.hasAttribute("class")) return;
	var v = (' '+e.getAttribute("class")+' ').replace(' '+cls+' ',' ').trim();
	if(v)e.setAttribute("class",v);
	else e.removeAttribute("class");
}

var map=[]; // a list of all nodes contained in the map.
var current={}; // stores information about the current state.  It has the fields:
// - 'node' the currently visited node,
// - 'can_move' boolean that is set to true when the player is allowed to make a move,
// - 'player' the player that is allowed to make the next move, value is "p1" or "p2".
var msgs={}; // contains text elements for 'notice', 'p1' and 'p2'.

// Adds a node to the map.
// Let n be a node:
//  - n.x,n.y denote the location of the node.
//  - n.exit tells what player can exit at this node. (0 if not an exit, default)
//  - n.element is the svg element that displays this node.
//  - n.used stores whether the node has been visited already.
var node=function(x,y,exit) {
	r={x:x,y:y,exit:exit||0,edges:[]};
	map.push(r);
	return r;
}

// Adds an edge to the map.
// Let e be an edge:
//  - e.a and e.b are the nodes connected by this edge.
//  - e.used tells whether this edge is in use. Such an edge can not be used to make a move.
//  - e.element the svg element used to display the edge.
var edge=function(na,nb,used) {
	r={a:na,b:nb,used:used||false};
	na.edges.push(r);
	nb.edges.push(r);
	if (used) na.used=nb.used=true;
	return r;
}

// Create a default map.
var create_map=function() {
	var square={}
	// Create nodes
	for (var y=-5;y<=5;y++) {
		for (var x=-5;x<=5;x++) {
			square[[x,y]]=node(x*SCALE,y*SCALE);
		}
	}
	// create edges
	for (var y=-5;y<=5;y++) {
		for (var x=-5;x<=5;x++) {
			if(y<5) {
				if (x==-5||x==5) {
					if (y!=0&&y!=-1) edge(square[[x,y]],square[[x,y+1]],used=true);
				} else {
					edge(square[[x,y]],square[[x,y+1]]);
				}
			}
			if(x<5) {
				if (y==-5||y==5) {
					edge(square[[x,y]],square[[x+1,y]],used=true);
				} else {
					edge(square[[x,y]],square[[x+1,y]]);
				}
			}
			if(x<5&&y<5) {
				edge(square[[x,y]],square[[x+1,y+1]]);
				edge(square[[x+1,y]],square[[x,y+1]]);
			}
		}
	}
	// create exit nodes
	square[[-5,0]].exit=1;
	square[[ 5,0]].exit=2;
	current.node=square[[0,0]];
	current.player="p1";
}
create_map();

var ai_random=function() {
	var N = current.node.edges.length;
	var s = Math.floor(Math.random()*N);
	var m = [2063,2069,2081,2083,2087,2089,2099,2111,2113,2129][Math.floor(Math.random()*N)];
	for (var i=0; i<N; i++) {
		var e = current.node.edges[(s+i*m)%N];
		if (!e.used) {
			return e.a==current.node?e.b:e.a;
		}
	}
	return false;
}

var selected_ai={p1:ai_random,p2:ai_random};

// If this node has only one edge remaining, then remove that edge.
// In that case prune the neighbouring node as well.
// This avoids any player to easily force a draw.
var prune_node=function(n) {
	var count = 0;
	var last;
	for (var j in n.edges) {
		var e=n.edges[j];
		if(!e.used) {
			count++;
			last = e;
		}
	}
	// Node is a dead end, prune it.
	if (count<=1) {
		add_class(n.element,"pruned");
	}
	if (count==1) {
		last.used=true;
		add_class(last.element,"pruned");
		prune_node(last.a==n?last.b:last.a);
	}
}

// Check the validity of the move
// If valid, mark the used edge as used.
var is_move_valid=function(n) {
	// a 'pass' is always valid
	if (n==current.node) return true;
	// Check if the new node is a neighbour of the current node, through an unused edge.
	for (var j in current.node.edges) {
		var e=current.node.edges[j];
		if(!e.used && (e.a==n || e.b==n)) {
			// It is valid. Apply the move.
			// Mark edge as used.
			add_class(e.element,"used");
			add_class(e.element,current.player);
			e.used=true;
			// Move is valid
			return true;
		}
	}
	return false;
}

// Checks whether the move is actually valid.
// If this is the case, initiate a move to the given node.
// Updating status and visual information of points and the walked edge.
var initiate_move=function(n) {
	// Verify that the game is still running
	if (!current.can_move) return;
	
	// Check if the clicked node is a valid move.
	if (!is_move_valid(n)) return;

	// clear previous allowed move markers
	for (var j in current.node.edges) {
		var e=current.node.edges[j];
		remove_class(e.a.element,"near");
		remove_class(e.b.element,"near");
		e.a.element.setAttribute("r",DEFAULT_DOT_RADIUS);
		e.b.element.setAttribute("r",DEFAULT_DOT_RADIUS);
	}

	// mark previous node as used. visualize new node (temporarily) as unused.
	if (n!=current.node) {
		add_class(current.node.element,"used");
		current.node.used=true;
		remove_class(n.element,"used");
	}

	// Move animation & current point color.
	// current.anim.setAttribute("transform","translate("+n.x+","+n.y+")");
	current.translate.setAttribute("values",current.node.x+","+current.node.y+";"+n.x+","+n.y);
	current.translate.beginElement();

	// Remove color from current node
	remove_class(current.node.element,current.player);
	prune_node(current.node);
	current.node=n;
	current.can_move=false;
}

// After finishing the animation
// Update the visuals for the new position
var update_current=function() {
	var n = current.node;
	if (n.exit) {
		// Provide end-of game message.
		msgs.notice.data="Player "+NAME[n.exit]+" has won!";
		add_class(msgs.notice.parentNode,"p"+n.exit);
		return;
	}
	current.can_move=true;
	if (!n.used) {
		// Change player if an unused node is hit.
		remove_class(current.anim,current.player);
		current.player = (current.player=="p1")?"p2":"p1";
		add_class(current.anim,current.player);
	}
	add_class(n.element,current.player);

	// Create new allowed move markers
	var last=false;
	var options=0;
	for (var j in n.edges) {
		var e=n.edges[j];
		if(!e.used) {
			var m=e.a==n?e.b:e.a;
			add_class(m.element,"near");
			m.element.setAttribute("r",NEAR_DOT_RADIUS);
			last=m;
			options++;
		}
	}

	if (options==0) {
		// Check for a tie.
		msgs.notice.data="The game is a tie!";
	} else if (options==1) {
		// Only one valid move available, so execute it immediately.
		initiate_move(last);
	} else {
		if (selected_ai[current.player]) {
			var move = selected_ai[current.player]();
			if (!move) {
				msgs.notice.data="Player "+NAME[n.exit]+" has given up!";
				add_class(msgs.notice.parentNode,"p"+n.exit);
				current.can_move=false;
				return;
			} else {
				initiate_move(move);
			}
		}
	}
}

// Adds an event handler for a point.
var add_move_handler=function(n) {
	n.element.addEventListener("click",function() {
		// Attempt to change the current position.
		initiate_move(n);
	},false);
}

// initialize
var onload=function(){
	var root=document.getElementById("root");
	var grid=add("g",root,{class:"grid"});
	current.anim=add("g",root,{class:"current"});
	var points=add("g",root,{class:"points"});
	msgs.notice = document.createTextNode("Welcome to Graph Walker.");
	add("text",root,{x:0,y:0.93,width:2,height:0.1}).appendChild(msgs.notice);
	msgs.p1 = document.createTextNode("Player "+NAME[1]);
	add("text",root,{x:-0.5,y:-0.87,width:2,height:0.1,class:"p1"}).appendChild(msgs.p1);
	msgs.p2 = document.createTextNode("Player "+NAME[2]);
	add("text",root,{x: 0.5,y:-0.87,width:2,height:0.1,class:"p2"}).appendChild(msgs.p2);

	// Create nodes and edges svg-elements.
	for (var i in map) {
		var n=map[i];
		// Create the node.
		n.element=add("circle",points,{cx:n.x,cy:n.y,r:DEFAULT_DOT_RADIUS});
		if (n.exit) n.element.setAttribute("class",["","exit p1","exit p2"][n.exit]);
		if (n.used) add_class(n.element,"used");

		// Add an click event handler to the node.
		add_move_handler(n);
		for (var j in n.edges) {
			var e=n.edges[j];
			if(!e.element) {
				// Create the edge.
				e.element=add("line",grid,{x1:e.a.x,y1:e.a.y,x2:e.b.x,y2:e.b.y});
				if (e.used) e.element.setAttribute("class","used initial");
			}
		}
	}

	// Do initial pruning.
	for (var i in map) {
		prune_node(map[i]);
	}
	
	// Create current animation.
	for (var i=0; i<2; i++) {
		var c=add("circle",current.anim,{cx:0,cy:0,r:0,class:"wave"});
		add("animate",c,{attributeName:"r", dur:"2s", begin:-i, values:".01;.05", repeatCount:"indefinite"});
		add("animate",c,{attributeName:"stroke-width", dur:"2s", begin:-i, values:".02;0", repeatCount:"indefinite"});
	}
	add("circle",current.anim,{cx:0,cy:0,r:DEFAULT_DOT_RADIUS});
	current.translate = add("animateTransform",current.anim,{attributeName:"transform", type:"translate", begin: "indefinite", dur:0.5, fill:"freeze"});
	current.translate.addEventListener("endEvent", update_current, false);
	update_current();
}
window.addEventListener("load",onload,false);
</script>
</head>
<body><svg xmlns="http://www.w3.org/2000/svg" viewbox="-1 -1 2 2" id="root"></svg></body>
</html>